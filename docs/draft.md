## fujimap 调研报告

### 原理

对于传统的 hash map，无论使用 linear probe 还是 chaining 处理冲突，都会导致一定的空间浪费，尤其是在 key/value 尺寸较小的情况下。为了减少内存损耗，研究人员提出了最小完美哈希函数，即通过计算出特定的哈希函数，从而将 key/value 紧凑地存储在数组中而不浪费任何空间。然而，这个方法一个致命的缺陷是 key/value 数目和内容必须已知，因此在动态变化的场景下需要不停地重建最小完美哈希。一个直观的做法是设定一个固定大小的 buffer，每次 buffer 插满就对其所包含的 key/value 批量建立最小完美哈希，这正是 fujimap 的核心思想之一。

在此基础上，如果我们的应用场景允许出现 false positive（例如我们想用来减小点查的读放大，只需要对于存在的主键能返回正确的位置即可。就算返回了假阳结果，也只是多读一次实际数据的开销），还可以进一步引入近似计算技术来极端地压缩空间占用，同时提供比较可观的查询性能，当然代价是构建 succinct 结构的耗时相对比较长，并且如果 key/value set 太大，计算最小完美哈希的耗时也会很长。

结合以上两点，fujimap 的原理就很容易理解了。首先自然是采用上文提到的 buffer hash table 来缓存插入的 key/value pair，插满以后将整个 buffer 中所有 raw key/value 进行处理，去重后转化成有序的 edges，即后续计算最小完美哈希时用来构建 hypergraph 的结构。为了进一步缩减空间占用，fujimap 并不实际存储 key 值，因此整个空间占用只和 value 大小以及假阳率有关。构建最小完美哈希时，如果直接对整个 buffer 的所有数据进行计算，内存占用会非常大，并且耗时会比较长。fujimap 的做法是先用一个简单的哈希函数将数据分区，将分区数记为 BlockN。每次 buffer 满时，将每个 key/value pair 划分到某个 block 中，再对 BlockN 个分区分别构建最小完美哈希。将每个 block 的大小限制在 4096 KB，这样每次加载一个 block 只需要一次 disk access。

总结一下 fujimap 涉及到的技术：

* 分层结构。buffer 输入，批量转化成空间、查询友好的 immutable part
* 近似计算。通过允许假阳性，极端压缩空间占用，同时保证较好的查询性能。从表现上来看，immutable part 类似一个能存 value 的 bloom filter
* 数据分区。为了避免过高的内存峰值占用和计算耗时，将一个 batch 的数据分区后分别构建最小完美哈希+succinct 结构，从而缓解压力。另一个角度来讲，分成若干个无依赖关系的 partition 在构建时也能具备更好的并行性

### 实现

### 性能

### 总结





